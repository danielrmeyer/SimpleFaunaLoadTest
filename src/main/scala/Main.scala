package example

import faunadb._
import java.util.concurrent.ConcurrentLinkedQueue
import scala.collection.mutable.ListBuffer
import scala.util.control.Breaks
import java.util.UUID.randomUUID


object Main extends App {
  //TODO read the following params from a config
  //CONFIGURATION PARAMETERS
  val numReaders = 10
  val numWriters = 5
  val numPreloadRecords = 20
  val serverSecret = "########################################"
  //END OF CONFIGURATION

  // results queue to hold data generated by agents
  // and streamed to a results.csv.
  val resultsQueue = new ConcurrentLinkedQueue[
    (Long, Long, Long, String, String) //TODO this structure is referred to in a few places making it hard to update.
  ]

  val client = FaunaClient(
    secret = serverSecret
  )

  // start the thread that will write out data in the results queue
  val resultsWriter = new ResultsWriter(resultsQueue)
  resultsWriter.setDaemon(true)
  resultsWriter.start()

  // generate test data to be pre loaded into collection
  var preLoadData = new ListBuffer[String]
  for (x <- 1 to numPreloadRecords) {
    preLoadData += (randomUUID().toString())
  }

  // generate and pre populate collection with test data for our reader agents
  Utils.populateCollection(client, preLoadData)

  // Start our writer and then reader agents
  val writerThreads = new ListBuffer[WriterAgent]
  for (x <- 1 to numWriters) {
    var wa = new WriterAgent(resultsQueue, client)
    writerThreads += wa
    wa.start()
  }

  val readerThreads = new ListBuffer[ReadingAgent]
  for (x <- 1 to numReaders) {
    var ra = new ReadingAgent(resultsQueue, preLoadData.toList, client)
    readerThreads += ra
    ra.start()
  }

  println("Waiting for threads to stop.")
  val loop = new Breaks
  loop.breakable {
    var activeWriterThreads = writerThreads.filter(_.isAlive())
    var activeReaderThreads = readerThreads.filter(_.isAlive())
    if (activeWriterThreads.isEmpty && activeReaderThreads.isEmpty)
      loop.break()
  }

  Thread.sleep(1000) // A little extra time for resultsQueue to write its last batch

  // Process results.csv and print out summary stats to console
  Utils.processResults(numReaders + numWriters)

}
